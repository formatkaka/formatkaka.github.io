"""
Battle routes - LLM battle API endpoints
"""

import asyncio
import json

from fastapi import APIRouter, BackgroundTasks, HTTPException
from fastapi.responses import StreamingResponse

from ..models.battle import BattleConfig, BattleRequest, BattleResponse, BattleStatus
from ..services.battle_service import BattleService
from ..services.surprise_service import SurpriseService

router = APIRouter(prefix="/api/battle", tags=["battle"])

# BattleService will be initialized in main.py with DB session
battle_service: BattleService | None = None
surprise_service = SurpriseService()


def set_battle_service(service: BattleService) -> None:
    """Set battle service instance (called from main.py)"""
    global battle_service
    battle_service = service


@router.get("/surprise")
async def get_surprise_config() -> dict:
    """
    Generate a random battle configuration using LLM.
    
    Returns a creative topic and 3 personas:
    - OpenAI: Mischievous troublemaker type
    - Claude: Polite peacemaker type  
    - Grok: Wildcard (anything creative!)
    """
    return await surprise_service.generate_surprise()


@router.post("/", response_model=BattleResponse)
async def create_battle(request: BattleRequest) -> BattleResponse:
    """
    Create a new battle between 3 LLMs.

    This creates the battle but doesn't start it.
    Use /api/battle/{id}/start to begin the battle.
    """
    if len(request.llms) != 3:
        raise HTTPException(
            status_code=400,
            detail="Exactly 3 LLMs are required for a battle",
        )

    state = battle_service.create_battle(request)
    return battle_service.get_battle_response(state)


@router.get("/", response_model=list[BattleResponse])
async def get_all_battles() -> list[BattleResponse]:
    """Get all battles"""
    return battle_service.get_all_battles()


@router.post("/{battle_id}/start", response_model=BattleResponse)
async def start_battle(
    battle_id: str,
    background_tasks: BackgroundTasks,
) -> BattleResponse:
    """
    Start a battle (runs in background).

    Poll /api/battle/{id} to get updates.
    """
    if not battle_service:
        raise HTTPException(status_code=500, detail="Battle service not initialized")
    
    state = battle_service.get_battle(battle_id)
    if not state:
        raise HTTPException(status_code=404, detail="Battle not found")

    if state.status != BattleStatus.PENDING:
        raise HTTPException(
            status_code=400,
            detail=f"Battle already {state.status.value}",
        )

    background_tasks.add_task(battle_service.run_battle, battle_id)
    state.status = BattleStatus.IN_PROGRESS

    return battle_service.get_battle_response(state)


@router.post("/{battle_id}/run", response_model=BattleResponse)
async def run_battle_sync(battle_id: str) -> BattleResponse:
    """
    Run a battle synchronously (waits for completion).

    Use this for simpler clients that don't need streaming.
    """
    if not battle_service:
        raise HTTPException(status_code=500, detail="Battle service not initialized")
    
    state = battle_service.get_battle(battle_id)
    if not state:
        raise HTTPException(status_code=404, detail="Battle not found")

    if state.status != BattleStatus.PENDING:
        raise HTTPException(
            status_code=400,
            detail=f"Battle already {state.status.value}",
        )

    await battle_service.run_battle(battle_id)
    return battle_service.get_battle_response(state)


@router.get("/{battle_id}/stream")
async def stream_battle(battle_id: str) -> StreamingResponse:
    """
    Stream battle messages as Server-Sent Events (SSE).

    Each message is sent as it's generated by the LLMs.
    """
    print(f"ðŸ“¡ Stream request for battle: {battle_id}")
    
    if not battle_service:
        raise HTTPException(status_code=500, detail="Battle service not initialized")
    
    state = battle_service.get_battle(battle_id)
    if not state:
        print(f"âŒ Battle not found: {battle_id}")
        raise HTTPException(status_code=404, detail="Battle not found")

    print(f"ðŸ“Š Battle status: {state.status.value}")
    if state.status != BattleStatus.PENDING:
        print(f"âš ï¸  Battle already {state.status.value}, cannot stream")
        raise HTTPException(
            status_code=400,
            detail=f"Battle already {state.status.value}",
        )

    async def event_generator():
        try:
            print(f"ðŸš€ Starting battle stream for: {battle_id}")
            message_count = 0
            async for message in battle_service.run_battle_streaming(battle_id):
                message_count += 1
                print(f"ðŸ“¨ Yielding message #{message_count}: {message.provider} - {message.content[:50]}...")
                data = json.dumps(message.model_dump())
                yield f"data: {data}\n\n"
                await asyncio.sleep(0.01)

            print(f"âœ… Battle stream complete. Total messages: {message_count}")
            yield f"data: {json.dumps({'type': 'complete'})}\n\n"
        except Exception as e:
            print(f"âŒ Stream error: {e}")
            import traceback
            traceback.print_exc()
            yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"

    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no",  # Disable nginx buffering
        },
    )


@router.get("/{battle_id}", response_model=BattleResponse)
async def get_battle(battle_id: str) -> BattleResponse:
    """Get current battle state"""
    if not battle_service:
        raise HTTPException(status_code=500, detail="Battle service not initialized")
    
    state = battle_service.get_battle(battle_id)
    if not state:
        raise HTTPException(status_code=404, detail="Battle not found")

    return battle_service.get_battle_response(state)


@router.get("/{battle_id}/config", response_model=BattleConfig)
async def get_battle_config(battle_id: str) -> BattleConfig:
    """Get battle configuration for replay"""
    if not battle_service:
        raise HTTPException(status_code=500, detail="Battle service not initialized")
    
    config = battle_service.get_battle_config(battle_id)
    if not config:
        raise HTTPException(status_code=404, detail="Battle not found")

    return config


@router.post("/{battle_id}/vote")
async def vote_for_battle(battle_id: str, request: dict) -> dict:
    """
    Save a vote for a battle.
    
    Args:
        battle_id: The battle ID
        request: JSON body with 'provider' field ('openai', 'claude', or 'grok')
    """
    if not battle_service:
        raise HTTPException(status_code=500, detail="Battle service not initialized")
    
    provider = request.get('provider')
    if not provider:
        raise HTTPException(status_code=400, detail="Missing 'provider' in request body")
    
    # Validate provider
    if provider not in ['openai', 'claude', 'grok']:
        raise HTTPException(status_code=400, detail="Invalid provider. Must be 'openai', 'claude', or 'grok'")
    
    # Verify battle exists
    state = battle_service.get_battle(battle_id)
    if not state:
        raise HTTPException(status_code=404, detail="Battle not found")
    
    try:
        battle_service.save_vote(battle_id, provider)
        return {"success": True, "message": "Vote saved"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error saving vote: {str(e)}")


@router.get("/{battle_id}/votes")
async def get_battle_votes(battle_id: str) -> dict:
    """Get vote counts for a battle"""
    if not battle_service:
        raise HTTPException(status_code=500, detail="Battle service not initialized")
    
    # Verify battle exists
    state = battle_service.get_battle(battle_id)
    if not state:
        raise HTTPException(status_code=404, detail="Battle not found")
    
    vote_counts = battle_service.get_vote_counts(battle_id)
    return vote_counts
